package MakePlus;

import OpenRate.process.AbstractRegexMatch;
import OpenRate.record.IRecord;
import OpenRate.record.RecordError;
import OpenRate.record.ErrorType;
import java.util.ArrayList;

/**
 * 
 */
public class PriceGroupMatch
  extends AbstractRegexMatch
{
  // this is the CVS version info
  public static String CVS_MODULE_INFO = "OpenRate, $RCSfile: PriceGroupMatch.java,v $, $Revision: 1.12 $, $Date: 2011/07/21 16:03:31 $";

  // String key used for searching
  private String[] tmpSearchParameters = new String[10];
    private ArrayList<String> RegexResult;
    private String RegexResultMatch;

  // -----------------------------------------------------------------------------
  // ------------------ Start of inherited Plug In functions ---------------------
  // -----------------------------------------------------------------------------

 /**
  * This is called when a data record is encountered. You should do any normal
  * processing here.
  */
  @Override
  public IRecord procValidRecord(IRecord r)
  {
    String RegexGroup;
    
    int Index;
    RecordError tmpError;
    CDRRecord CurrentRecord = (CDRRecord) r;

    if (CurrentRecord.RECORD_TYPE == CDRRecord.CDR_RECORD)
    {        
      // Prepare the paramters to perform the search on
      tmpSearchParameters[2]=CurrentRecord.ZoneOrigin;
      tmpSearchParameters[3]=CurrentRecord.Network;
      tmpSearchParameters[4]=CurrentRecord.Direction;
      tmpSearchParameters[5]=CurrentRecord.RemoteNetwork;
      tmpSearchParameters[6]=CurrentRecord.PortingPrefix;
      tmpSearchParameters[7]=CurrentRecord.Type;
      tmpSearchParameters[8]=CurrentRecord.Service;
      tmpSearchParameters[9]=CurrentRecord.RemoteSwitch;

      for (Index = 0; Index < CurrentRecord.getChargePacketCount(); Index++)
      {
        tmpSearchParameters[0]=CurrentRecord.getChargePacket(Index).ZoneResult;
        tmpSearchParameters[1]=CurrentRecord.getChargePacket(Index).TimeResult;

        RegexGroup = getRatePlan(CurrentRecord.getChargePacket(Index).RatePlanName, CurrentRecord.getChargePacket(Index).PacketType);
        CurrentRecord.getChargePacket(Index).RatePlanName = RegexGroup; 

        // Look up the rate model to use
        RegexResultMatch = getRegexMatch(RegexGroup,tmpSearchParameters);

        // See if we get a match on the specific plan
        if (RegexResultMatch.equals("NOMATCH"))
        {
          // No match on the specific plan - try to look if there is a base rateplan
          if ((CurrentRecord.BaseRateplan != null) && (CurrentRecord.BaseRateplan.length()>0))
          {
            RegexGroup = getRatePlan(CurrentRecord.BaseRateplan, CurrentRecord.getChargePacket(Index).PacketType);
            CurrentRecord.getChargePacket(Index).RatePlanName = RegexGroup; 
            //RegexResult = getRegexMatch(RegexGroup,tmpSearchParameters);
            
            RegexResult = getRegexMatchWithChildData(RegexGroup,tmpSearchParameters);
            if (RegexResult.get(0).equals("NOMATCH"))
            {
              tmpError = new RecordError("ERR_PRICE_MODEL_NOT_FOUND_"+CurrentRecord.getChargePacket(Index).PacketType, ErrorType.DATA_NOT_FOUND);
              tmpError.setModuleName(getSymbolicName());
              tmpError.setErrorDescription("Could not find price model for base rate plan:"+CurrentRecord.BaseRateplan + " charge packet type " + CurrentRecord.getChargePacket(Index).PacketType);
              CurrentRecord.addError(tmpError);
              return r;
            }
            else
            {
              // falling back on the base rateplan
              CurrentRecord.getChargePacket(Index).RatePlanName = CurrentRecord.BaseRateplan;
              CurrentRecord.getChargePacket(Index).PriceGroup = RegexResult.get(0);
              CurrentRecord.getChargePacket(Index).PriceModel = RegexResult.get(0);
            }
          }
        }
        else
        {
          CurrentRecord.getChargePacket(Index).PriceGroup = RegexResult.get(0);
          CurrentRecord.getChargePacket(Index).PriceModel = RegexResult.get(0);
          if (CurrentRecord.getChargePacket(Index).PacketType.equals("W")){
              CurrentRecord.WholesaleDescription = RegexResult.get(1);

          }
          else if (CurrentRecord.getChargePacket(Index).PacketType.equals("R")){
              CurrentRecord.RetailDescription = RegexResult.get(1);
          }
          else if (CurrentRecord.getChargePacket(Index).PacketType.equals("LC")){
              CurrentRecord.LocalCostDescription = RegexResult.get(1);
          }
          else if (CurrentRecord.getChargePacket(Index).PacketType.equals("RC")){
              CurrentRecord.RemoteCostDescription = RegexResult.get(1);
          }
          else if (CurrentRecord.getChargePacket(Index).PacketType.equals("LT")){
              CurrentRecord.LocalTransitDescription = RegexResult.get(1);
          }
          else if (CurrentRecord.getChargePacket(Index).PacketType.equals("RT")){
              CurrentRecord.RemoteTransitDescription = RegexResult.get(1);
          }
        }
      }
    }

    return r;
  }

 /**
  * This is called when a data record with errors is encountered. You should do
  * any processing here that you have to do for error records, e.g. stratistics,
  * special handling, even error correction!
  */
  @Override
  public IRecord procErrorRecord(IRecord r)
  {
    return r;
  }
  
  public String getRatePlan(String ratePlanName, String packetType)
  {
    if (packetType.equals("R") | packetType.equals("W"))
    {
      return ratePlanName + "_" + packetType;
    }
    else
    {
      return packetType;
    }
  }
}

